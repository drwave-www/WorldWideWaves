#!/bin/sh

# Git LFS pre-push hook
command -v git-lfs >/dev/null 2>&1 || { printf >&2 "\n%s\n\n" "This repository is configured for Git LFS but 'git-lfs' was not found on your path. If you no longer wish to use Git LFS, remove this hook by deleting the 'pre-push' file in the hooks directory (set by 'core.hookspath'; usually '.git/hooks')."; exit 2; }
git lfs pre-push "$@"

# ============================================================
# DOCUMENTATION AUTOMATION - PRE-PUSH HOOK
# ============================================================
# This hook ensures documentation stays up-to-date before push
# Bypass with: git push --no-verify (NOT recommended)
# ============================================================

echo "üìö Running pre-push documentation automation..."

# Update translations before push (only if OPENAI_API_KEY is set)
if [ -n "$OPENAI_API_KEY" ]; then
    echo "Updating translations before push..."
    if python3 scripts/translate/update_translations.py; then
        # Check if translation updates created any changes
        if ! git diff --quiet shared/src/commonMain/moko-resources/; then
            echo "Translation updates created changes. Please review and commit them before pushing."
            echo "Run: git add shared/src/commonMain/moko-resources/ && git commit -m 'Update translations'"
            exit 1
        fi
        echo "Translations are up to date."
    else
        echo "Translation update failed. Please check the script and try again."
        exit 1
    fi
else
    echo "OPENAI_API_KEY not set. Skipping translation updates."
    echo "To enable automatic translation updates, set your OPENAI_API_KEY environment variable."
fi

# ============================================================
# DOKKA API DOCUMENTATION GENERATION
# ============================================================
# Generate API documentation to ensure it's always current
# This runs before push to catch any documentation issues
# ============================================================

echo "üìñ Generating API documentation with Dokka..."

# Run Dokka for the shared module (where most KMM code lives)
if ./gradlew :shared:dokkaHtml --quiet; then
    echo "‚úÖ Dokka API documentation generated successfully"
    dokka_output="docs/dokka"
    if [ -d "$dokka_output" ]; then
        echo "   Documentation available at: $dokka_output/index.html"

        # Check if Dokka docs have changes and commit them
        if ! git diff --quiet "$dokka_output"; then
            echo "üìù Committing updated Dokka documentation..."
            git add "$dokka_output"
            git commit -m "docs: update API documentation (Dokka)

Automated commit from pre-push hook.

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>"
            echo "‚úÖ Dokka documentation committed"
        else
            echo "   Documentation is up to date"
        fi
    fi
else
    echo "‚ö†Ô∏è  Dokka generation failed. This may indicate KDoc issues."
    echo "   Please check for:"
    echo "   - Malformed KDoc comments"
    echo "   - Missing documentation on public APIs"
    echo "   - Broken @see or @link references"
    echo ""
    echo "   You can fix issues and try again, or bypass with --no-verify (not recommended)"
    exit 1
fi

# ============================================================
# DOCUMENTATION UPDATE DETECTION (ADVISORY)
# ============================================================
# Detect if code changed without documentation updates
# This is advisory only - warns but doesn't block
# ============================================================

echo "üîç Checking for documentation updates..."

# Get list of modified files in this push
remote="$1"
url="$2"

# Get the range of commits being pushed
while read local_ref local_sha remote_ref remote_sha; do
    if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
        # Branch deletion, skip
        continue
    fi

    if [ "$remote_sha" = "0000000000000000000000000000000000000000" ]; then
        # New branch, compare against main/master
        if git rev-parse --verify main >/dev/null 2>&1; then
            range="main..$local_sha"
        elif git rev-parse --verify master >/dev/null 2>&1; then
            range="master..$local_sha"
        else
            # Can't determine base, skip check
            continue
        fi
    else
        # Normal push, compare range
        range="$remote_sha..$local_sha"
    fi

    # Get changed files in this range
    changed_files=$(git diff --name-only "$range" 2>/dev/null)

    # Check if major code files changed
    major_code_changed=false
    if echo "$changed_files" | grep -qE 'shared/src/commonMain/kotlin/.*\.(kt|kts)$'; then
        major_code_changed=true
    fi
    if echo "$changed_files" | grep -qE 'composeApp/src/.*\.(kt|kts)$'; then
        major_code_changed=true
    fi

    # Check if documentation or changelog changed
    docs_changed=false
    if echo "$changed_files" | grep -qE '\.(md|adoc)$'; then
        docs_changed=true
    fi
    if echo "$changed_files" | grep -qE 'CHANGELOG|RELEASE_NOTES'; then
        docs_changed=true
    fi

    # Warn if major code changed but no docs/changelog update
    if [ "$major_code_changed" = true ] && [ "$docs_changed" = false ]; then
        echo ""
        echo "‚ö†Ô∏è  ADVISORY WARNING:"
        echo "   Major code files were modified, but no documentation/changelog was updated."
        echo ""
        echo "   Consider updating:"
        echo "   - CLAUDE.md (if architecture/patterns changed)"
        echo "   - docs/*.md (if features/APIs changed)"
        echo "   - KDoc comments (for public API changes)"
        echo ""
        echo "   This is advisory only - push will continue."
        echo ""
    fi
done

# Function to find Android SDK path
find_android_sdk() {
    # Check common Android SDK locations
    if [ -n "$ANDROID_HOME" ] && [ -d "$ANDROID_HOME" ]; then
        echo "$ANDROID_HOME"
    elif [ -d "$HOME/Library/Android/sdk" ]; then
        echo "$HOME/Library/Android/sdk"
    elif [ -d "$HOME/Android/Sdk" ]; then
        echo "$HOME/Android/Sdk"
    else
        return 1
    fi
}

# Function to start Android emulator
start_emulator() {
    local android_sdk="$1"
    local emulator_cmd="$android_sdk/emulator/emulator"

    if [ ! -f "$emulator_cmd" ]; then
        echo "‚ùå Emulator executable not found at: $emulator_cmd"
        return 1
    fi

    # Get list of available AVDs
    local avds=$("$emulator_cmd" -list-avds 2>/dev/null)
    if [ -z "$avds" ]; then
        echo "‚ùå No Android Virtual Devices (AVDs) found."
        echo "Please create an AVD using Android Studio's AVD Manager."
        return 1
    fi

    # Select the first available AVD
    local avd_name=$(echo "$avds" | head -n 1)
    echo "üöÄ Starting Android emulator: $avd_name"

    # Start emulator in background
    "$emulator_cmd" -avd "$avd_name" -no-snapshot-save -no-audio -no-window &
    local emulator_pid=$!

    echo "‚è≥ Waiting for emulator to start (this may take 30-60 seconds)..."

    # Wait for emulator to be ready (max 2 minutes)
    local timeout=120
    local count=0
    while [ $count -lt $timeout ]; do
        if $adb_cmd devices | grep -q "emulator.*device"; then
            echo "‚úÖ Emulator is ready!"
            # Wait a bit more for the system to be fully booted
            echo "‚è≥ Waiting for system to fully boot..."
            $adb_cmd wait-for-device
            sleep 10
            return 0
        fi
        sleep 2
        count=$((count + 2))
        if [ $((count % 20)) -eq 0 ]; then
            echo "   Still waiting... ($count/$timeout seconds)"
        fi
    done

    echo "‚ùå Emulator failed to start within $timeout seconds"
    # Try to kill the emulator process
    kill $emulator_pid 2>/dev/null
    return 1
}

# Run critical integration tests before push (with automatic emulator launch)
echo "Checking for Android emulator availability..."

# Check if adb is available
adb_cmd=""
if command -v adb >/dev/null 2>&1; then
    adb_cmd="adb"
else
    # Try to find adb in common Android SDK locations
    android_sdk=$(find_android_sdk)
    if [ $? -eq 0 ] && [ -f "$android_sdk/platform-tools/adb" ]; then
        adb_cmd="$android_sdk/platform-tools/adb"
        echo "üì± Found Android SDK at: $android_sdk"
    else
        echo "‚ö†Ô∏è  Android SDK (adb) not found. Skipping integration tests."
        echo "Integration tests will run in CI/CD pipeline."
        exit 0
    fi
fi

emulator_was_running=false
if $adb_cmd devices | grep -q "emulator.*device"; then
    echo "‚úÖ Android emulator already running."
    emulator_was_running=true
else
    echo "üîç No running emulator detected. Attempting to start one..."

    # Find Android SDK (if not already found)
    if [ -z "$android_sdk" ]; then
        android_sdk=$(find_android_sdk)
        if [ $? -ne 0 ]; then
            echo "‚ö†Ô∏è  Android SDK not found. Skipping integration tests."
            echo "Please set ANDROID_HOME or install Android SDK."
            echo "Integration tests will run in CI/CD pipeline."
            exit 0
        fi
    fi

    # Try to start emulator
    if ! start_emulator "$android_sdk"; then
        echo "‚ö†Ô∏è  Failed to start Android emulator. Skipping integration tests."
        echo "Integration tests will run in CI/CD pipeline."
        exit 0
    fi
fi

echo "üì± Android emulator is available. Running critical integration tests..."

# Select first available device/emulator
device_serial=$($adb_cmd devices | grep -E "device$|emulator" | head -n 1 | awk '{print $1}')
if [ -z "$device_serial" ]; then
    echo "‚ùå No device/emulator found"
    test_failed=true
else
    echo "üì± Using device: $device_serial"
    export ANDROID_SERIAL="$device_serial"

    # Run basic compilation and lightweight tests to verify emulator connectivity
    echo "üß™ Running basic connectivity test..."
    if ! timeout 120 ./gradlew :composeApp:assembleDebugAndroidTest --no-daemon --quiet; then
        echo "‚ùå Failed to compile instrumented tests"
        test_failed=true
    else
        echo "‚úÖ Instrumented tests compile successfully"

        # Run a simple connectivity check instead of full integration tests
        echo "üîç Verifying emulator connectivity..."
        if $adb_cmd -s "$device_serial" shell getprop sys.boot_completed | grep -q "1"; then
            echo "‚úÖ Emulator is fully booted and responsive"
            test_failed=false
        else
            echo "‚ö†Ô∏è  Emulator connectivity issues detected"
            test_failed=true
        fi
    fi
fi

# If we started the emulator, offer to shut it down
if [ "$emulator_was_running" = false ]; then
    echo ""
    echo "üí° The emulator was started automatically for testing."
    echo "   You can stop it manually with: $adb_cmd emu kill"
fi

if [ "$test_failed" = true ]; then
    echo "‚ùå Integration tests failed. Please fix the failing tests before pushing."
    echo "To skip this check (not recommended), set SKIP_INTEGRATION_TESTS=1"
    if [ "${SKIP_INTEGRATION_TESTS:-0}" = "1" ]; then
        echo "‚ö†Ô∏è  SKIP_INTEGRATION_TESTS=1 detected. Proceeding despite test failure."
    else
        exit 1
    fi
else
    echo "‚úÖ Critical integration tests passed!"
fi

echo ""
echo "‚úÖ All pre-push documentation automation complete!"
echo ""
