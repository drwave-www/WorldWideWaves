@file:OptIn(kotlin.time.ExperimentalTime::class)

package com.worldwidewaves.shared.domain.scheduling

/*
 * Copyright 2025 DrWave
 *
 * WorldWideWaves is an ephemeral mobile app designed to orchestrate human waves through cities and
 * countries. The project aims to transcend physical and cultural
 * boundaries, fostering unity, community, and shared human experience by leveraging real-time
 * coordination and location-based services.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import com.worldwidewaves.shared.events.IWWWEvent
import com.worldwidewaves.shared.events.IWWWEvent.Status
import com.worldwidewaves.shared.events.utils.IClock
import com.worldwidewaves.shared.events.WWWEventWave
import io.mockk.coEvery
import io.mockk.every
import io.mockk.mockk
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.flow.take
import kotlinx.coroutines.flow.toList
import kotlinx.coroutines.test.runTest
import kotlinx.datetime.Instant
import kotlin.test.Test
import kotlin.test.assertEquals
import kotlin.test.assertFalse
import kotlin.test.assertTrue
import kotlin.time.Duration.Companion.INFINITE
import kotlin.time.Duration.Companion.ZERO
import kotlin.time.Duration.Companion.days
import kotlin.time.Duration.Companion.hours
import kotlin.time.Duration.Companion.milliseconds
import kotlin.time.Duration.Companion.minutes
import kotlin.time.Duration.Companion.seconds

class DefaultObservationSchedulerTest {

    private val mockClock = mockk<IClock>()
    private val mockEvent = mockk<IWWWEvent>()
    private val mockWave = mockk<WWWEventWave>()

    private val scheduler = DefaultObservationScheduler(mockClock)

    private val baseTime = Instant.parse("2025-01-01T12:00:00Z")

    @Test
    fun `calculateObservationInterval - distant event returns 1 hour`() = runTest {
        // Given: Event is more than 1 hour + 5 minutes away
        every { mockClock.now() } returns baseTime
        every { mockEvent.getStartDateTime() } returns baseTime + 2.hours
        every { mockEvent.wave } returns mockWave
        every { mockWave.timeBeforeUserHit() } returns 2.hours

        // When
        val result = scheduler.calculateObservationInterval(mockEvent)

        // Then
        assertEquals(1.hours, result)
    }

    @Test
    fun `calculateObservationInterval - approaching event returns 5 minutes`() = runTest {
        // Given: Event is between 5:30 and 65 minutes away
        every { mockClock.now() } returns baseTime
        every { mockEvent.getStartDateTime() } returns baseTime + 30.minutes
        every { mockEvent.wave } returns mockWave
        every { mockWave.timeBeforeUserHit() } returns 30.minutes

        // When
        val result = scheduler.calculateObservationInterval(mockEvent)

        // Then
        assertEquals(5.minutes, result)
    }

    @Test
    fun `calculateObservationInterval - near event returns 1 second`() = runTest {
        // Given: Event is between 35 seconds and 5:30 minutes away
        every { mockClock.now() } returns baseTime
        every { mockEvent.getStartDateTime() } returns baseTime + 2.minutes
        every { mockEvent.wave } returns mockWave
        every { mockWave.timeBeforeUserHit() } returns 2.minutes

        // When
        val result = scheduler.calculateObservationInterval(mockEvent)

        // Then
        assertEquals(1.seconds, result)
    }

    @Test
    fun `calculateObservationInterval - active event returns 500ms`() = runTest {
        // Given: Event is starting or running
        every { mockClock.now() } returns baseTime
        every { mockEvent.getStartDateTime() } returns baseTime + 10.seconds
        coEvery { mockEvent.isRunning() } returns false
        every { mockEvent.wave } returns mockWave
        every { mockWave.timeBeforeUserHit() } returns 10.seconds

        // When
        val result = scheduler.calculateObservationInterval(mockEvent)

        // Then
        assertEquals(500.milliseconds, result)
    }

    @Test
    fun `calculateObservationInterval - running event returns 500ms`() = runTest {
        // Given: Event is running
        every { mockClock.now() } returns baseTime
        every { mockEvent.getStartDateTime() } returns baseTime - 1.minutes
        coEvery { mockEvent.isRunning() } returns true
        every { mockEvent.wave } returns mockWave
        every { mockWave.timeBeforeUserHit() } returns 5.minutes

        // When
        val result = scheduler.calculateObservationInterval(mockEvent)

        // Then
        assertEquals(500.milliseconds, result)
    }

    @Test
    fun `calculateObservationInterval - critical hit timing returns 50ms`() = runTest {
        // Given: User will be hit in less than 1 second
        every { mockClock.now() } returns baseTime
        every { mockEvent.getStartDateTime() } returns baseTime - 1.minutes
        coEvery { mockEvent.isRunning() } returns true
        every { mockEvent.wave } returns mockWave
        every { mockWave.timeBeforeUserHit() } returns 500.milliseconds

        // When
        val result = scheduler.calculateObservationInterval(mockEvent)

        // Then
        assertEquals(50.milliseconds, result)
    }

    @Test
    fun `calculateObservationInterval - near hit timing returns 200ms`() = runTest {
        // Given: User will be hit in less than 5 seconds but more than 1 second
        every { mockClock.now() } returns baseTime
        every { mockEvent.getStartDateTime() } returns baseTime - 1.minutes
        coEvery { mockEvent.isRunning() } returns true
        every { mockEvent.wave } returns mockWave
        every { mockWave.timeBeforeUserHit() } returns 3.seconds

        // When
        val result = scheduler.calculateObservationInterval(mockEvent)

        // Then
        assertEquals(200.milliseconds, result)
    }

    @Test
    fun `calculateObservationInterval - user already hit returns infinite`() = runTest {
        // Given: User has already been hit
        every { mockClock.now() } returns baseTime
        every { mockEvent.getStartDateTime() } returns baseTime - 1.minutes
        coEvery { mockEvent.isRunning() } returns true
        every { mockEvent.wave } returns mockWave
        every { mockWave.timeBeforeUserHit() } returns -1.seconds

        // When
        val result = scheduler.calculateObservationInterval(mockEvent)

        // Then
        assertEquals(INFINITE, result)
    }

    @Test
    fun `calculateObservationInterval - post event monitoring returns 30 seconds`() = runTest {
        // Given: Event is done but monitoring continues
        every { mockClock.now() } returns baseTime
        every { mockEvent.getStartDateTime() } returns baseTime - 10.minutes
        coEvery { mockEvent.isRunning() } returns false
        every { mockEvent.wave } returns mockWave
        every { mockWave.timeBeforeUserHit() } returns 10.seconds

        // When
        val result = scheduler.calculateObservationInterval(mockEvent)

        // Then
        assertEquals(30.seconds, result)
    }

    @Test
    fun `shouldObserveContinuously - running event returns true`() = runTest {
        // Given: Event is running
        coEvery { mockEvent.isRunning() } returns true
        coEvery { mockEvent.isSoon() } returns false
        coEvery { mockEvent.isNearTime() } returns false

        // When
        val result = scheduler.shouldObserveContinuously(mockEvent)

        // Then
        assertTrue(result)
    }

    @Test
    fun `shouldObserveContinuously - soon and near time returns true`() = runTest {
        // Given: Event is soon and near time
        coEvery { mockEvent.isRunning() } returns false
        coEvery { mockEvent.isSoon() } returns true
        coEvery { mockEvent.isNearTime() } returns true

        // When
        val result = scheduler.shouldObserveContinuously(mockEvent)

        // Then
        assertTrue(result)
    }

    @Test
    fun `shouldObserveContinuously - soon but not near time returns false`() = runTest {
        // Given: Event is soon but not near time
        coEvery { mockEvent.isRunning() } returns false
        coEvery { mockEvent.isSoon() } returns true
        coEvery { mockEvent.isNearTime() } returns false

        // When
        val result = scheduler.shouldObserveContinuously(mockEvent)

        // Then
        assertFalse(result)
    }

    @Test
    fun `shouldObserveContinuously - not running and not soon returns false`() = runTest {
        // Given: Event is not running and not soon
        coEvery { mockEvent.isRunning() } returns false
        coEvery { mockEvent.isSoon() } returns false
        coEvery { mockEvent.isNearTime() } returns false

        // When
        val result = scheduler.shouldObserveContinuously(mockEvent)

        // Then
        assertFalse(result)
    }

    @Test
    fun `createObservationFlow - not ready for continuous observation emits once`() = runTest {
        // Given: Event is not ready for continuous observation
        every { mockEvent.id } returns "test-event"
        coEvery { mockEvent.isRunning() } returns false
        coEvery { mockEvent.isSoon() } returns false
        coEvery { mockEvent.isNearTime() } returns false

        // When
        val emissions = scheduler.createObservationFlow(mockEvent).take(1).toList()

        // Then
        assertEquals(1, emissions.size)
        assertEquals(Unit, emissions.first())
    }

    @Test
    fun `createObservationFlow - continuous observation emits multiple times`() = runTest {
        // Given: Event ready for continuous observation that becomes done after 2 iterations
        every { mockEvent.id } returns "test-event"
        coEvery { mockEvent.isRunning() } returns true
        coEvery { mockEvent.isSoon() } returns false
        coEvery { mockEvent.isNearTime() } returns false

        var callCount = 0
        coEvery { mockEvent.isDone() } answers { ++callCount > 2 }

        every { mockClock.now() } returns baseTime
        every { mockEvent.getStartDateTime() } returns baseTime + 1.minutes
        every { mockEvent.wave } returns mockWave
        every { mockWave.timeBeforeUserHit() } returns 1.minutes
        coEvery { mockClock.delay(any()) } returns Unit

        // When
        val emissions = scheduler.createObservationFlow(mockEvent).take(4).toList()

        // Then
        assertTrue(emissions.size >= 3) // Initial + iterations + final
        assertTrue(emissions.all { it == Unit })
    }

    @Test
    fun `getObservationSchedule - returns complete schedule information`() = runTest {
        // Given: Event in approaching phase
        every { mockClock.now() } returns baseTime
        every { mockEvent.getStartDateTime() } returns baseTime + 30.minutes
        coEvery { mockEvent.isRunning() } returns false
        coEvery { mockEvent.isSoon() } returns true
        coEvery { mockEvent.isNearTime() } returns true
        coEvery { mockEvent.isDone() } returns false
        every { mockEvent.wave } returns mockWave
        every { mockWave.timeBeforeUserHit() } returns 30.minutes

        // When
        val schedule = scheduler.getObservationSchedule(mockEvent)

        // Then
        assertTrue(schedule.shouldObserve)
        assertEquals(5.minutes, schedule.interval)
        assertEquals(ObservationPhase.APPROACHING, schedule.phase)
        assertEquals(baseTime + 5.minutes, schedule.nextObservationTime)
        assertTrue(schedule.reason.contains("approaching"))
    }

    @Test
    fun `getObservationSchedule - inactive event has no next observation time`() = runTest {
        // Given: Event is done
        every { mockClock.now() } returns baseTime
        every { mockEvent.getStartDateTime() } returns baseTime - 1.hours
        coEvery { mockEvent.isRunning() } returns false
        coEvery { mockEvent.isSoon() } returns false
        coEvery { mockEvent.isNearTime() } returns false
        coEvery { mockEvent.isDone() } returns true
        every { mockEvent.wave } returns mockWave
        every { mockWave.timeBeforeUserHit() } returns null

        // When
        val schedule = scheduler.getObservationSchedule(mockEvent)

        // Then
        assertFalse(schedule.shouldObserve)
        assertEquals(INFINITE, schedule.interval)
        assertEquals(ObservationPhase.INACTIVE, schedule.phase)
        assertEquals(null, schedule.nextObservationTime)
        assertTrue(schedule.reason.contains("done"))
    }

    @Test
    fun `observation phases - critical phase for imminent hit`() = runTest {
        // Given: User will be hit very soon
        every { mockClock.now() } returns baseTime
        every { mockEvent.getStartDateTime() } returns baseTime - 1.minutes
        coEvery { mockEvent.isRunning() } returns true
        coEvery { mockEvent.isSoon() } returns true
        coEvery { mockEvent.isNearTime() } returns true
        coEvery { mockEvent.isDone() } returns false
        every { mockEvent.wave } returns mockWave
        every { mockWave.timeBeforeUserHit() } returns 2.seconds

        // When
        val schedule = scheduler.getObservationSchedule(mockEvent)

        // Then
        assertEquals(ObservationPhase.CRITICAL, schedule.phase)
        assertTrue(schedule.reason.contains("Critical hit timing"))
    }

    @Test
    fun `observation phases - active phase for running event`() = runTest {
        // Given: Event is running but user hit is not imminent
        every { mockClock.now() } returns baseTime
        every { mockEvent.getStartDateTime() } returns baseTime - 1.minutes
        coEvery { mockEvent.isRunning() } returns true
        coEvery { mockEvent.isSoon() } returns true
        coEvery { mockEvent.isNearTime() } returns true
        coEvery { mockEvent.isDone() } returns false
        every { mockEvent.wave } returns mockWave
        every { mockWave.timeBeforeUserHit() } returns 10.seconds

        // When
        val schedule = scheduler.getObservationSchedule(mockEvent)

        // Then
        assertEquals(ObservationPhase.ACTIVE, schedule.phase)
        assertTrue(schedule.reason.contains("active"))
    }

    @Test
    fun `observation phases - near phase for upcoming event`() = runTest {
        // Given: Event is near (within 5 minutes)
        every { mockClock.now() } returns baseTime
        every { mockEvent.getStartDateTime() } returns baseTime + 2.minutes
        coEvery { mockEvent.isRunning() } returns false
        coEvery { mockEvent.isSoon() } returns true
        coEvery { mockEvent.isNearTime() } returns true
        coEvery { mockEvent.isDone() } returns false
        every { mockEvent.wave } returns mockWave
        every { mockWave.timeBeforeUserHit() } returns 2.minutes

        // When
        val schedule = scheduler.getObservationSchedule(mockEvent)

        // Then
        assertEquals(ObservationPhase.NEAR, schedule.phase)
        assertTrue(schedule.reason.contains("near"))
    }

    @Test
    fun `observation phases - distant phase for far future event`() = runTest {
        // Given: Event is far in the future
        every { mockClock.now() } returns baseTime
        every { mockEvent.getStartDateTime() } returns baseTime + 3.hours
        coEvery { mockEvent.isRunning() } returns false
        coEvery { mockEvent.isSoon() } returns false
        coEvery { mockEvent.isNearTime() } returns false
        coEvery { mockEvent.isDone() } returns false
        every { mockEvent.wave } returns mockWave
        every { mockWave.timeBeforeUserHit() } returns 3.hours

        // When
        val schedule = scheduler.getObservationSchedule(mockEvent)

        // Then
        assertEquals(ObservationPhase.DISTANT, schedule.phase)
        assertTrue(schedule.reason.contains("minimal monitoring"))
    }
}