package com.worldwidewaves.shared.sound

/*
 * Copyright 2025 DrWave
 *
 * WorldWideWaves is an ephemeral mobile app designed to orchestrate human waves through cities and
 * countries. The project aims to transcend physical and cultural
 * boundaries, fostering unity, community, and shared human experience by leveraging real-time
 * coordination and location-based services.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import com.worldwidewaves.shared.WWWGlobals
import com.worldwidewaves.shared.utils.Log
import kotlinx.cinterop.CPointer
import kotlinx.cinterop.ExperimentalForeignApi
import kotlinx.cinterop.allocArray
import kotlinx.cinterop.get
import kotlinx.cinterop.memScoped
import kotlinx.cinterop.set
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import kotlinx.coroutines.withContext
import platform.AVFAudio.AVAudioEngine
import platform.AVFAudio.AVAudioFormat
import platform.AVFAudio.AVAudioPCMBuffer
import platform.AVFAudio.AVAudioPlayerNode
import platform.AVFAudio.AVAudioSession
import platform.AVFAudio.AVAudioSessionCategoryOptionMixWithOthers
import platform.AVFAudio.AVAudioSessionCategoryPlayback
import platform.AVFAudio.outputVolume
import platform.AVFAudio.setActive
import platform.Foundation.NSError
import kotlin.time.Duration
import kotlin.time.Duration.Companion.milliseconds

/**
 * iOS implementation of SoundPlayer using AVAudioEngine
 */
@OptIn(ExperimentalForeignApi::class)
class IOSSoundPlayer :
    SoundPlayer,
    VolumeController {
    companion object {
        private const val TAG = "IOSSoundPlayer"
        private const val SAMPLE_RATE = WWWGlobals.Audio.STANDARD_SAMPLE_RATE
    }

    private val audioSession = AVAudioSession.sharedInstance()
    private val audioEngine = AVAudioEngine()
    private val playerNode = AVAudioPlayerNode()
    private val audioFormat: AVAudioFormat
    private val playbackMutex = Mutex()
    private var isEngineStarted = false

    init {
        // Create audio format for PCM playback
        audioFormat = AVAudioFormat(
            standardFormatWithSampleRate = SAMPLE_RATE.toDouble(),
            channels = WWWGlobals.Audio.DEFAULT_CHANNELS.toUInt()
        )!!

        setupAudioSession()
        setupAudioEngine()
    }

    @Throws(Throwable::class)
    private fun setupAudioSession() {
        try {
            audioSession.setCategory(
                AVAudioSessionCategoryPlayback,
                AVAudioSessionCategoryOptionMixWithOthers,
                null
            )

            audioSession.setActive(true, null)

            Log.v(TAG, "Audio session setup completed")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to setup audio session", e)
            throw e
        }
    }

    @Throws(Throwable::class)
    private fun setupAudioEngine() {
        try {
            // Attach player node to engine
            audioEngine.attachNode(playerNode)

            // Connect player node to output
            audioEngine.connect(
                playerNode,
                audioEngine.outputNode,
                audioFormat,
            )

            // Prepare and start engine
            audioEngine.prepare()
            audioEngine.startAndReturnError(null)

            isEngineStarted = true
            Log.v(TAG, "Audio engine setup completed")
        } catch (e: Exception) {
            Log.e(TAG, "Failed to setup audio engine", e)
            throw e
        }
    }

    override fun getCurrentVolume(): Float = audioSession.outputVolume()

    override fun setVolume(level: Float) {
        // Note: iOS doesn't allow direct volume control from apps without special entitlements
        // Apps must use MPVolumeView for user-controlled volume changes
        Log.v(TAG, "Volume control on iOS requires user interaction via MPVolumeView")
    }

    override suspend fun playTone(
        frequency: Double,
        amplitude: Double,
        duration: Duration,
        waveform: SoundPlayer.Waveform,
    ) = withContext(Dispatchers.Default) {
        playbackMutex.withLock {
            try {
                if (!isEngineStarted) {
                    Log.w(TAG, "Audio engine not started, cannot play tone")
                    return@withContext
                }

                Log.v(TAG, "Playing tone: freq=$frequency, amp=$amplitude, dur=$duration, wave=$waveform")

                // Generate waveform samples using shared generator
                val samples =
                    WaveformGenerator.generateWaveform(
                        sampleRate = SAMPLE_RATE,
                        frequency = frequency,
                        amplitude = amplitude,
                        duration = duration,
                        waveform = waveform,
                    )

                // Convert to iOS audio buffer and play
                playAudioSamples(samples)

                // Wait for playback to complete
                delay(duration + 50.milliseconds)

                Log.v(TAG, "Tone playback completed")
            } catch (e: Exception) {
                Log.e(TAG, "Error playing tone: freq=$frequency, dur=$duration", e)
                throw e
            }
        }
    }

    @Throws(Throwable::class)
    private suspend fun playAudioSamples(samples: DoubleArray) =
        withContext(Dispatchers.Main) {
            try {
                // Create PCM buffer for the samples
                val frameCount = samples.size.toUInt()
                val buffer =
                    AVAudioPCMBuffer(PCMFormat = audioFormat, frameCapacity = frameCount)
                        ?: throw IllegalStateException("Failed to create AVAudioPCMBuffer")

                buffer.frameLength = frameCount

                // Convert double samples to Float32 format expected by iOS
                memScoped {
                    val floatArray = allocArray<kotlinx.cinterop.FloatVar>(samples.size)
                    samples.forEachIndexed { index, sample ->
                        // Convert double sample to float and clamp to valid range
                        floatArray[index] = sample.toFloat().coerceIn(-1.0f, 1.0f)
                    }

                    // Copy samples to audio buffer
                    val audioBufferList = buffer.audioBufferList!!
                    val audioBuffer = audioBufferList.pointed.mBuffers
                    platform.posix.memcpy(
                        audioBuffer.mData,
                        floatArray,
                        (samples.size * 4).toULong(), // 4 bytes per float
                    )
                }

                // Schedule and play the buffer
                playerNode.scheduleBuffer(buffer, completionHandler = null)

                if (!playerNode.isPlaying()) {
                    playerNode.play()
                }

                Log.v(TAG, "Audio buffer scheduled and playing")
            } catch (e: Exception) {
                Log.e(TAG, "Failed to play audio samples", e)
                throw e
            }
        }

    override fun release() {
        try {
            playbackMutex.tryLock()

            if (playerNode.isPlaying()) {
                playerNode.stop()
            }

            if (isEngineStarted) {
                audioEngine.stop()
                isEngineStarted = false
            }

            val error: CPointer<NSError>? = null
            audioSession.setActive(false, error)

            if (error != null) {
                Log.w(TAG, "Audio session deactivation warning")
            }

            Log.v(TAG, "iOS sound player released")
        } catch (e: Exception) {
            Log.e(TAG, "Error during sound player release", e)
        } finally {
            if (playbackMutex.isLocked) {
                playbackMutex.unlock()
            }
        }
    }
}
